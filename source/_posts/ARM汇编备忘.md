---
title: ARM汇编备忘
date: 2019-10-22 20:33:42
tags:
---

    寄存器 x0-x3存储的为函数入参，x16存储的为函数编号

SP   保存栈指针 指的是堆栈指针寄存器，在堆栈操作中使用，PUSH和POP指令是从SP寄存器得到现行堆栈段的段内偏移量，所以称SP寄存器为堆栈指针，SP始终指向栈顶。
LP(X30)  通常称X30为程序链接寄存器，保存跳转返回信息地址
FP(x29) 保存栈帧地址（栈底指针）
x0-x30 通用寄存器，如果有需要可以当做32bit使用: w0-w30   w2 代表只用 2 号寄存器的 32 位。
PC 程序计数器，俗称PC指针，总是指向即将要执行的下一条指令

x0-x7: 用于子程序调用时的参数传递，x0还用于返回值传递
x8: 间接寻址结果
LR: 保存子程序结束后需要执行的下一条指令

register read 可以在断点的时候获取寄存器的数值

sub 用于对寄存器实施减法，sub a,b,c 等价于a = b - c，在ARM汇编中，目的操作数一般出现在最前方，例如mov ra,rb 代表将rb寄存器的值复制到ra寄存器
add  与sub同理

str和ldr 是一对指令
str : store register  将寄存器的值存储到内存中  story  register to memory
ldr : load register 将内存中的值读到寄存器      load memory to register
他们的第一个参数都是寄存器，第二个参数都是内存地址
[sp, #12] 代表 sp + 12 这个地址
[sp, #-12] 代表 sp - 12这个地址
都是以字节为单位的偏移量
str w0,[sp,#12] w是4字节的寄存器，这个指令代表
将 w0寄存器的值存储在sp + 12这个地址上，由于w0有4个字节，所以存储后会占据sp+12 ~ sp+16这个内存区域

int test(int a, int b) {
  int res = a + b;
  return res;
}
编译生成如下汇编代码，未进行优化，所以存在冗余操作
	sub	sp, sp, #16             ; =16    将sp指针下移16字节，留下4个4字节的内存空间
	str	w0, [sp, #12]           将w0存储在sp+12的格子中
	str	w1, [sp, #8]            将w1存储在sp+8的格子中
	ldr	w0, [sp, #12]           将a从内存中读到寄存器w0
	ldr	w1, [sp, #8]            将b从内存中读到寄存器w1
	add w0, w0, w1              执行加法操作，并将结果保存在w0寄存器
	str	w0, [sp, #4]            将寄存器w0的值存储到sp+4的内存地址，也就是res变量的内存区域
	ldr	w0, [sp, #4]            将sp+4的内存地址的值读取到w0寄存器，准备返回
	add	sp, sp, #16             ; =16   将栈还原，并返回到函数调用处继续向下执行,注意：栈空间中内存单元并未被清空
	ret
在编译器生成汇编时，首先会计算需要的栈空间大小，并利用sp指针指向低地址开辟相应的空间
分析：
    涉及了3个int 变量，分别是a、b、res,int 变量占据4个字节，因此一共需要12个字节
    但是ARM64汇编为了提高访问效率要求按照16字节进行对齐，因此需要16字节的空间，也就是需要在站上开辟16字节的空间
    x0和w0是同一个寄存器的不同尺寸形式，x0为8字节，w0为x0的前4字节，因此w0是函数的第一个入参，w1是函数的第二个入参b
    由于存储是从低地址到高地址的，所以a将占据sp+12~sp+16 同理b将占据sp+8~sp+12
    注意：只有寄存器才能参与运算
    函数的返回值一般存储在x0寄存器中返回，因此需要将res的值载入x0寄存器，这里之所以使用w寄存器，是因为int为4字节，这也就是类型转换时带来信息丢失的原因
    例如从long到int的转换就类似于将x寄存器的值以w的形式进行存储。



.section .data
    <初始化数据>
.section .bss
    <未初始化数据>
.section .text
.global_start
_start:
    <汇编代码>

注意：一般是将上面结构进行简化
.text 
.global _start
_start
    <汇编代码>

寄存器操作指令:
    算数和逻辑指令:
        mov: 将一个寄存器或被移位寄存器或一个立即数移动到目的寄存器
        mov r1,#8  (注意：#+数 表示一个十进制数，#+0b数，表示一个二进制数，#+0x数，表示十六进制数)

        MVN : 对源操作数取反再赋值给目的寄存器
        sub : 将一个数减去另外一个数再存放到寄存器
        add : 将一个数加上另一个数后将其存放到寄存器中
        and : 逻辑与
        bic : 位清除
            bic R1,R2,#0B1101  将R2中所有与#0B1101中1所对应的位清零后的结果保存在R1中
    比较指令:
        cmp : 用于比较两个数的大小，比较的结果不会放在哪个通用寄存器中而是改在程序状态寄存器中的一个标志状态位
        tst : 测试位，将两个数按位与
    分支指令:
        b : 条件跳转指令
        b [条件] 标号  （注意：中括号在编写程序时不需要写出）
        bl : 带连接的返回 类似C语言中的子函数调用，调用子函数后返回主函数)
    移位指令:
        lsl : 算术左移位
        mov R1,R1,lsl#2 (将R1中的数据左移两位存入R1)

        ror : 循环右移
        mov r1,r1,#ror 2 (将r1中的数据循环右移后存入R1中)

        AND X0，X0，#0xF ; X0的值与0xF相位与后的值传送到X0
        ORR X0，X0，#9 ; X0的值与9相或后的值传送到X0
        EOR X0，X0，#0xF ; X0的值与0xF相异或后的值传送到X0
    程序状态字访问指令:
        上面的指令都不能对计算机中的程序状态字中的指令进行访问和读写，所以需要专用计算机指令来将程序状态字中的数据读写到通用寄存器中，再进行休后写入
        mrs : 将程序状态字中的数据搬出来
        mrs r0,cprs
        msr : 将数据搬回程序状态字中
        msr cprs,r0
    存储器操作指令:
        ldr: 将内存中的值导出到通用寄存器中  
        ldr r0,#0XFF
        LDR X5，[X6，#0x08] ；X6寄存器加0x08的和的地址值内的数据传送到X5
        str: 将通用寄存器中的数据回写到内存中

    伪指令：
        定义类伪指令：1、编译时起作用 2、起作用但是转化为其他机器指令
        .global 表明一个全局的符号 （注意GNU伪指令的特点是前面加上一个".")
        .data 定义一个数据段
        .ascii 定义字符串的数据
        .byte 定义一个字节的数据
        .word 定义一个字的数据
        .data 
        .equ 类似于C语言中定义宏
        .align 用于字节对齐
    操作类伪指令
        nop : 空操作指令，具体实现： mov r0,r0 
        ldr: 用于将一个大于八位的数据装入寄存器
        注意: ldr r0,=0x1ff

    协处理指令：最重要就是CP15
    作用：系统控制

    stp: 入栈指令
    stur： 偏移量为负数往低地址偏移，使用stur指令
    str: 偏移量为正数往高地址偏移
    ldp: 出栈指令，从指定内存中读取数据到一对寄存器中，p是pair的意思
    ldr: 地址没有偏移或者编译为正数时使用
    ldur: 地址编译为负数时使用
    adr: 小范围的地址读取指令，将基于PC相对偏移的地址值读取到寄存器中
    adrp: 以页为单位的大范围的地址读取指令，这里的p就是page的意思
    ret: 子程序返回指令，返回地址默认保存在LR(X30)

rbp 寄存器 (基础指针寄存器 base pointer register

汇编结合一点点思考，我们得出了一些 非常非常重要 的结论：
“不给别人添麻烦”：每个函数都有自己的一块操作空间，我们称其为“栈帧(stack frame)”。寄存器 fp、sp 的值是栈帧范围的唯一标识，作为 simple 函数，为了保证自己 return 之后，调用者能继续正常执行，函数体需要自己负责维护 fp/sp 的状态，保证进出时一致。而正是因为大家都遵循这样的规则，在后续代码中，我们才能放心的在调用完 count: 之后，继续使用 fp/sp 寄存器。

“自己的事情自己做”：一个函数有多少参数、多少局部变量，进而需要多大的栈空间，只有函数自己知道，所以函数内部需要自己“挪动” fp、sp 的指向，来“声明”自己所需要的空间。

“一切行动听指挥”：我们知道，lr 寄存器存储着返回地址，当函数内部又有函数调用时，我们不可避免的需要改变 lr 寄存器的值，那么为了保证自己能成功回到上一级，函数自己需要将 lr 地址存好，并在执行结束之前重新设置给 lr 寄存器。

NZCV是状态寄存器中存的几个状态值，分别代表运算过程中产生的状态，其中：
    N, negative condition flag，一般代表运算结果是负数
    Z, zero condition flag, 运算结果为0
    C, carry condition flag, 无符号运算有溢出时，C=1。
    V, oVerflow condition flag 有符号运算有溢出时，V=1。


栈
栈就是指令执行时存放临时变量的内存空间，具有特殊的访问方式：后进先出， Last In Out Firt。
    栈是从高地址到低地址存储数据的，栈底是高地址，栈顶是低地址。
    FP指向栈底
    SP指向栈顶
